package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

// С использованием sync/atomic
type ConcurrentCounter struct {
	value int64
}

// Конструктор для создания нового счетчика
// Инициализирует значение счетчика в 0
// Возвращает указатель на новый экземпляр ConcurrentCounter
// Используется для обеспечения потокобезопасности при инкрементации и чтении
// счетчика в многопоточной среде
func NewCounter() *ConcurrentCounter {
	return &ConcurrentCounter{}
}

// Инкрементирует значение счетчика на 1
// Использует атомарную операцию для обеспечения потокобезопасности
// Это позволяет нескольким горутинам безопасно увеличивать счетчик
// без риска гонок данных
// Не возвращает значение, так как операция инкрементации не требует
// возврата результата, просто увеличивает внутреннее значение счетчика
func (c *ConcurrentCounter) Increment() {
	atomic.AddInt64(&c.value, 1)
}

// Возвращает текущее значение счетчика
// Использует атомарную операцию для безопасного чтения значения счетчика
// Это позволяет избежать гонок данных при чтении значения счетчика
// Возвращает текущее значение счетчика как int64
func (c *ConcurrentCounter) GetValue() int64 {
	return atomic.LoadInt64(&c.value)
}

func main() {
	fmt.Println("Atomic Counter")
	// Создаем новый экземпляр счетчика
	// Это позволяет нам использовать его в многопоточной среде
	counter := NewCounter()

	var wg sync.WaitGroup
	// Количество горутин, которые будут инкрементировать счетчик
	// Это значение определяет, сколько параллельных операций инкрементации будет
	// выполняться одновременно
	goroutines := 100
	// Количество инкрементов для каждой горутины
	// Это значение определяет, сколько раз каждая горутина будет увеличивать счетчик
	incrementsPerGoroutine := 1000 // 1000 инкрементов на горутину

	// Запускаем горутины
	for i := 0; i < goroutines; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			// Каждая горутина инкрементирует счетчик заданное количество раз
			for j := 0; j < incrementsPerGoroutine; j++ {
				counter.Increment()
			}
		}()
	}

	// Ждем завершения всех горутин
	wg.Wait()

	// Выводим итоговое значение - 100 горутин × 1000 инкрементов = 100,000
	fmt.Printf("Итоговое значение счетчика: %d\n", counter.GetValue())
	fmt.Printf("Ожидаемое значение: %d\n", goroutines*incrementsPerGoroutine)
}
